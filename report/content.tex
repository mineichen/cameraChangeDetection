\chapter{Algorithm }
\section{Functionality}
The algorithm consists of two phases. In the first phase, an entire image is scanned to find prominent pixels, whose coordinates are stored in a vector. In the following images, the algorithm just calculates these specific points and checks if this point is still considered to be prominent. If there are too many points which are not prominent anymoore, a change is triggered and the next image is scanned for new prominent pixels. 

\subsection{Phase 1; Finding pixels of interest}
To find the pixels of interest (POI), the entire image is scanned with parts of the Harris edge filter.  But instead of finding local maximums to detect the corners, the algorithm divides the image into a configurable amount of subsections, horizontally and vertically. Each subsection is scanned for it's biggest corner-value. If this value exceeds a predefined threshold, his coordinates and his value are stoored into a vector. This selection leads to a better distribution accross the image. 

\begin{figure}[h!]
	\centering
	\includegraphics[width=0.9\linewidth]{bin/hotspots}
	\caption{Camera image with a overlay of found edges in each subsection}
	\label{fig:hotspots}
\end{figure} 


\subsection{Phase 2; Check pixels of interest}
From this point, just the coordinates stored in the vector which was created in phase 1 are calculated.  For each touple in the vector (e.g. x,y,value) newValue is determined in the new image at position x:y. When newValue is at least half as big as value, the point which the touple represents is still considered to be an corner. This relative solution, which is based on the previous value resulted in much less noise then when comparing it again to the threshold in Phase 1, because values close to the threshold were toggling to be a corner or not in each frame. Furthermoore, neighbour pixels of very strong edges were still considered to be edges, even though the image moved. 

If the amount of missing corners becomes bigger than a percentage of the vectorsize, a change is triggered and Phase 1 executes to recalculate the vector. When the amount of found edges stabilizes on a count bigger than half of the expected amount of found corners , the  camera can be considered stable again.

\subsection{Why Harris}
Compared to simple Edge-Filters as Sobel or Prewitt, Harris finds corners where edges from Prewitt- or Sobelfilters are coming together. Therefore they are fragile to changes in all directions, whereas sobel and Prewitt are not fragil when the camera moves along the edges. The chance of accidentally hitting another corner is very small.



\section{Influences}
\subsection{Light changes}
Because the algorithm operates on the corner-values, it is not vulnerable to small light changes. If light changes often causes unwanted change events, the algorithm might be extended to operate on the color images of YUV instead of the grayscale image. But this was not covered within this project.

\subsection{Slow movement}
By selecting fixed points, this solution can also detect very slow changes of the camera, which is a requirement of a changesystem who should trigger a recalibration.

\subsection{ Partial changes}
As stated out in the requirements, the algorithm shouldn't trigger a change if just parts of the scene are moving or overlapped. 
\subsubsection{Distribution}
To achieve this tolerance it is important, that the POIs are well distributed over the image, which is assured by dividing the image into a grid to find maximums instead of finding local maximums, as suggested in the original Harris-Filter. Otherwise, a small object might overlap multiple important points which results in a change event.
\subsubsection{ Emphasis }
Furthermoore it is important that all POIs have the same significance. Instead of comparing the sum up of all POI-Value-Differences compared with the Phase1 image, we count the amount of Points which are still considered to be edges in the new image.


\chapter{Technical decisions}
\section{Halide}
Because the same algorithm must run over the entire image in the first place and afterwards over specific pixels only, it is important that the  algorithm could handle both tasks in order to avoid the effort of programming everything twice and, more imprtant, assure that it always has the same result. In Rasp

\subsection{32 Bit Kernel}
Even though the Raspberry PI 3 has a 64bit processor, at the time of writing, there are no mature linux distributions with a 64bit kernel out there for the raspberry. As soon as they're available, I would suggest to switch to a 64Bit kernel in order to take advantage of many additional CPU-registers for better performance.

\section{Type casting}
As shown in figure x, C doesn't handle overflows consistently. Even thought it is a 64 Bit System, which was determined by printing sizeof($int^*$), overflows in uint8\_t were preserved on shift back whereas uint32\_t looses this information. Even thought this project might benefit from using 8bit calculations, 8 bit values are casted to 16 bit before a calculation whose intermediate results exceed 255 to assure a portable and stable solution.

\begin{minted}[linenos=true]{cpp}
#include <stdio.h>
#include <stdint.h>
#include <limits.h>

int main()
{
	uint32_t a = UULONG_MAX>>32,
		b = UULONG_MAX>>32,
		res = (uint32_t)((a+b)>>1);
	printf("Result(%lu): %lu\n", a, res);
	
	return 0;
}
\end{minted}
\textit{ Result (4294967295): 2147483647 \\
	(2\textsuperscript{32})-1: 2\textsuperscript{31}
}
\begin{minted}[linenos=true]{cpp}
#include <stdio.h>
#include <stdint.h>
#include <limits.h>

int main()
{
	uint8_t a = 255,
		b = 255,
	res = (uint8_t)((a+b)>>1);
	printf("Result(%u): %u\n", a,res);
	
	return 0;
}

\end{minted}
\textit{ Result(255): 255 } \\
To assure repeatability, this experiment was executed on \\ https://www.tutorialspoint.com/compile\_c\_online.php.


\chapter {Technical implementation}
\section{ Docker }
This project uses docker, a lightwight container virtualization solution, to develop and test the quality of the algorithms. All images used in this project are published on hub.docker.com. Because they are autobuilt, which means that hub.docker.com builds them out of so called Dockerfiles, you can reliably see, how these images are set up. In order to execute the provided commands, it is sufficient to have docker up and running.

\section{Build process}
All required files are available under \enquote{https://github.com/mineichen/cameraChangeDetection}. The build process is split into two phases and is not fully automated yet.
 
\begin{enumerate}
	\item{ Generate the harris-filter as a static C library}
	\item{ Compile the GStreamer plugin which contains all the logic}
\end{enumerate}

In order to execute the build commands, the current working directory has to be the same as the project root directory.

\subsection{Harris-Filter}
The Harris-filter is build with the halide programming language. Because halide comes with a cross-compiler built in, the harris binaries for the development-platform and the raspberry pi are compiled inside of a halide-docker-container. The resulting static library inside build/*platform* doesn't have any dependencies to halide. To change the target platform, the \enquote{platform}-variable in halide/build.sh has to be changed.

\begin{lstlisting}[language=bash]
$ docker-compose run halide sh code/build.sh
\end{lstlisting}

For development purpose, the precompiler-condition in the main function could be changed to apply the algorithm to a single png image. 

\subsection{Gstreamer-Plugin}
Unlike the Harris filter, the Gstreamer-Plugin isn't prepared to be cross compiled. Therefore, the compilation is done on the platform by executing the \enquote{gstreamer/build.sh} script. For development purpose, the following command builds the dynamic-library, which has to be linked to gst-launch at runtime.

\begin{lstlisting}[language=bash]
docker-compose run gstreamer sh code/build.sh
\end{lstlisting}

The static Harris-Filter-library has to be copied into the gstreamer/lib/ folder  to be found by the compiler. \enquote{gstreamer/codes.txt} contains useful gst-launch pipelines with examples.

\chapter{Results}
In this chapter, the amount of corners found in the scenes are documented. The red line represents the amount of corners expected to be found and the blue line represents the amount of corners actually found at the given coordinates. During the analysis, the parameter which determines, which percentage of the original edgevalue a following point has to have, to be considered an corner, had a big influence in the result. Therefore the following sections contain the result with the parameters 50\% and 75\%.
\section{Method}
The following data is generated with a pipeline inside 

\section{Bump}

\begin{tikzpicture}
	\begin{axis}[
          width=\linewidth, % Scale the plot to \linewidth
          height=200,
          grid=major, % Display a grid
          grid style={dashed,gray!30}, % Set the style
          xlabel=Framenumber, % Set the labels
          ylabel=Nr. of matching points,
          %x unit=\si{\volt}, % Set the respective units
          %y unit=\si{\ampere},
          legend style={at={(0.5,-0.2)},anchor=north}, % Put the legend below the plot
          x tick label style={anchor=north,yshift=-2}, % Display labels sideways
          y tick label style={anchor=east,xshift=-2},
          ymin=0,
          xmin=0,
          xmax=200
        ]
		\addplot table [x=frame, y=points, col sep=comma] {data/bump/final.csv};
		\addplot table [x=frame, y=total, col sep=comma] {data/bump/final.csv};
	\end{axis}
\end{tikzpicture}

\begin{tikzpicture}
\begin{axis}[
width=\linewidth, % Scale the plot to \linewidth
height=200,
grid=major, % Display a grid
grid style={dashed,gray!30}, % Set the style
xlabel=Framenumber, % Set the labels
ylabel=Nr. of matching points,
%x unit=\si{\volt}, % Set the respective units
%y unit=\si{\ampere},
legend style={at={(0.5,-0.2)},anchor=north}, % Put the legend below the plot
x tick label style={anchor=north,yshift=-2}, % Display labels sideways
y tick label style={anchor=east,xshift=-2},
ymin=0,
xmin=0,
xmax=200
]
\addplot table [x=frame, y=points, col sep=comma] {data/bump/final3div4.csv};
\addplot table [x=frame, y=total, col sep=comma] {data/bump/final3div4.csv};
\end{axis}
\end{tikzpicture}

\section{Scene change}
\begin{tikzpicture}
	\begin{axis}[
          width=\linewidth, % Scale the plot to \linewidth
          height=200,
          grid=major, % Display a grid
          grid style={dashed,gray!30}, % Set the style
          xlabel=Framenumber, % Set the labels
          ylabel=Nr. of matching points,
          %x unit=\si{\volt}, % Set the respective units
          %y unit=\si{\ampere},
          legend style={at={(0.5,-0.2)},anchor=north}, % Put the legend below the plot
          x tick label style={anchor=north,yshift=-2}, % Display labels sideways
          y tick label style={anchor=east,xshift=-2},
          ymin=0,
          xmin=0,
          xmax=300
        ]
		\addplot table [x=frame, y=points, col sep=comma] {data/sceneChange/final.csv};
		\addplot table [x=frame, y=total, col sep=comma] {data/sceneChange/final.csv};
	\end{axis}
\end{tikzpicture}
\begin{tikzpicture}
\begin{axis}[
width=\linewidth, % Scale the plot to \linewidth
height=200,
grid=major, % Display a grid
grid style={dashed,gray!30}, % Set the style
xlabel=Framenumber, % Set the labels
ylabel=Nr. of matching points,
%x unit=\si{\volt}, % Set the respective units
%y unit=\si{\ampere},
legend style={at={(0.5,-0.2)},anchor=north}, % Put the legend below the plot
x tick label style={anchor=north,yshift=-2}, % Display labels sideways
y tick label style={anchor=east,xshift=-2},
ymin=0,
xmin=0,
xmax=300
]
\addplot table [x=frame, y=points, col sep=comma] {data/sceneChange/final3div4.csv};
\addplot table [x=frame, y=total, col sep=comma] {data/sceneChange/final3div4.csv};
\end{axis}
\end{tikzpicture}
\subsection{NoChange}


\begin{tikzpicture}
	\begin{axis}[
          width=\linewidth, % Scale the plot to \linewidth
          height=200,
          grid=major, % Display a grid
          grid style={dashed,gray!30}, % Set the style
          xlabel=Framenumber, % Set the labels
          ylabel=Nr. of matching points,
          %x unit=\si{\volt}, % Set the respective units
          %y unit=\si{\ampere},
          legend style={at={(0.5,-0.2)},anchor=north}, % Put the legend below the plot
          x tick label style={anchor=north,yshift=-2}, % Display labels sideways
          y tick label style={anchor=east,xshift=-2},
          ymin=0,
          xmin=0
        ]
		\addplot table [x=frame, y=points, col sep=comma] {data/noChange/final.csv};
		\addplot table [x=frame, y=total, col sep=comma] {data/noChange/final.csv};
	\end{axis}
\end{tikzpicture}

\begin{tikzpicture}
\begin{axis}[
width=\linewidth, % Scale the plot to \linewidth
height=200,
grid=major, % Display a grid
grid style={dashed,gray!30}, % Set the style
xlabel=Framenumber, % Set the labels
ylabel=Nr. of matching points,
%x unit=\si{\volt}, % Set the respective units
%y unit=\si{\ampere},
legend style={at={(0.5,-0.2)},anchor=north}, % Put the legend below the plot
x tick label style={anchor=north,yshift=-2}, % Display labels sideways
y tick label style={anchor=east,xshift=-2},
ymin=0,
xmin=0
]
\addplot table [x=frame, y=points, col sep=comma] {data/noChange/final3div4.csv};
\addplot table [x=frame, y=total, col sep=comma] {data/noChange/final3div4.csv};
\end{axis}
\end{tikzpicture}

\subsection{Horizontal Move}


\begin{tikzpicture}
\begin{axis}[
width=\linewidth, % Scale the plot to \linewidth
height=200,
grid=major, % Display a grid
grid style={dashed,gray!30}, % Set the style
xlabel=Framenumber, % Set the labels
ylabel=Nr. of matching points,
%x unit=\si{\volt}, % Set the respective units
%y unit=\si{\ampere},
legend style={at={(0.5,-0.2)},anchor=north}, % Put the legend below the plot
x tick label style={anchor=north,yshift=-2}, % Display labels sideways
y tick label style={anchor=east,xshift=-2},
ymin=0,
xmin=0,
xmax=100
]
\addplot table [x=frame, y=points, col sep=comma] {data/horizontalMove/final.csv};
\addplot table [x=frame, y=total, col sep=comma] {data/horizontalMove/final.csv};
\end{axis}
\end{tikzpicture}

\begin{tikzpicture}
\begin{axis}[
width=\linewidth, % Scale the plot to \linewidth
height=200,
grid=major, % Display a grid
grid style={dashed,gray!30}, % Set the style
xlabel=Framenumber, % Set the labels
ylabel=Nr. of matching points,
%x unit=\si{\volt}, % Set the respective units
%y unit=\si{\ampere},
legend style={at={(0.5,-0.2)},anchor=north}, % Put the legend below the plot
x tick label style={anchor=north,yshift=-2}, % Display labels sideways
y tick label style={anchor=east,xshift=-2},
ymin=0,
xmin=0,
xmax=100
]
\addplot table [x=frame, y=points, col sep=comma] {data/horizontalMove/final3div4.csv};
\addplot table [x=frame, y=total, col sep=comma] {data/horizontalMove/final3div4.csv};
\end{axis}
\end{tikzpicture}


\subsection{Vertical Move}


\begin{tikzpicture}
\begin{axis}[
width=\linewidth, % Scale the plot to \linewidth
height=200,
grid=major, % Display a grid
grid style={dashed,gray!30}, % Set the style
xlabel=Framenumber, % Set the labels
ylabel=Nr. of matching points,
%x unit=\si{\volt}, % Set the respective units
%y unit=\si{\ampere},
legend style={at={(0.5,-0.2)},anchor=north}, % Put the legend below the plot
x tick label style={anchor=north,yshift=-2}, % Display labels sideways
y tick label style={anchor=east,xshift=-2},
ymin=0,
xmin=0,
xmax=100
]
\addplot table [x=frame, y=points, col sep=comma] {data/verticalMove/final.csv};
\addplot table [x=frame, y=total, col sep=comma] {data/verticalMove/final.csv};
\end{axis}
\end{tikzpicture}
\begin{tikzpicture}
\begin{axis}[
width=\linewidth, % Scale the plot to \linewidth
height=200,
grid=major, % Display a grid
grid style={dashed,gray!30}, % Set the style
xlabel=Framenumber, % Set the labels
ylabel=Nr. of matching points,
%x unit=\si{\volt}, % Set the respective units
%y unit=\si{\ampere},
legend style={at={(0.5,-0.2)},anchor=north}, % Put the legend below the plot
x tick label style={anchor=north,yshift=-2}, % Display labels sideways
y tick label style={anchor=east,xshift=-2},
ymin=0,
xmin=0,
xmax=100
]
\addplot table [x=frame, y=points, col sep=comma] {data/verticalMove/final3div4.csv};
\addplot table [x=frame, y=total, col sep=comma] {data/verticalMove/final3div4.csv};
\end{axis}
\end{tikzpicture}

\section{Conclusion}
Because of the requirements to have a low false negative rate, the parameter 75\% should be favourized